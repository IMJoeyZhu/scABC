sort_peaks <- function(peaks){
  return(peaks[order(peaks$chrom, peaks$start), ])
}

#' select peaks
#'
#' read in peaks into a table and select only those with MACS2 pValue > 1 (p < 0.1)
#' @param filename of a bed12+3 gapped peaks file obtain from peaking calling using MACS2
#' @return significant peaks obtained by filtering by p-value
#' @keywords peaks
#' @export selectPeaks
selectPeaks <- function(filename, thresh = 2){
  peaks = read.table(file = filename, header = FALSE, sep = "\t",
                     stringsAsFactors = FALSE);
  if(dim(peaks)[2] == 15){
    # gapped peaks
    column_names = c("chrom", "start", "end", "name", "score", "strand",
                     "thickStart", "thickEnd", "itemRgb", "blockCount", "blockSizes",
                     "blockStarts", "signalValue", "pValue", "qValue");
    colnames(peaks) = column_names
  }
  if(dim(peaks)[2] == 10){
    # narrow peaks
    column_names = c("chrom", "start", "end", "name", "score", "strand",
                     "foldChange", "pValue", "qValue", "summit2PeakDist")
    colnames(peaks) = column_names
  }

  wanted_peaks = which(peaks$pValue > thresh); # pValue is -log10(p), p < 0.1 => pValue > 2
  peaks = sort_peaks(peaks[wanted_peaks, ])
  return(peaks)
}

peaks2GRanges <- function(peaks, upstream = 0, downstream = 0){
  peaks.gr = with(peaks, GenomicRanges::GRanges(chrom, IRanges::IRanges(sapply(start, function(x) max(0, x - upstream)), end + downstream), id = name, pVal = pValue))
}

# peaks should be in GenomicRanges
get_counts_from_bam <- function(bamfile, peaks){
  param = Rsamtools::ScanBamParam(which = peaks, what = c("rname", "pos", "strand", "qwidth"))
  counts = Rsamtools::countBam(bamfile, param = param,
                               flag = Rsamtools::scanBamFlag(isDuplicate = FALSE,
                                                             isUnmappedQuery = FALSE))
  return(counts[,c("space", "start", "end", "file", "records")])
}


getTagCounts <- function(RGtag, bamfile, peaks){
  RGparam = ScanBamParam(which = peaks,
                         what = c("rname", "pos", "strand", "qwidth"),
                         tagFilter = list(RG= c("RG", RGtag)))
  counts = countBam(bamfile,
                    param = RGparam,
                    flag = Rsamtools::scanBamFlag(isDuplicate = FALSE,
                                                  isUnmappedQuery = FALSE))
  return(counts$records)
}

#getCountsByReadGroup <- function(bamfile, peaks){
#  scanned <- scanBam(bamfile,
#                     param = ScanBamParam(what = c("rname", "pos"),
#                                                   tag = "RG"))[[1]]
#  RGtags = unique(scanned$tag$RG)
#
#  counts = do.call(cbind, lapply(RGtags, function(x) getTagCounts(x, bamfile, peaks)))
#  colnames(counts) = RGtags
#
#  return(counts)
#}

getCountsByReadGroup <- function(bamfile, peaks, RGtag, tags = NULL, PAIRED = FALSE, VERBOSE = FALSE){
  scanned <- Rsamtools::scanBam(bamfile,
                     param = Rsamtools::ScanBamParam(what = c("rname", "pos", "strand", "qwidth"),
                                          tag = RGtag))[[1]]
  if(is.null(tags)){
    tags = unique(scanned$tag[tag])
  }
  counts_mat = Matrix::Matrix(0, nrow = length(peaks), 
                              ncol = length(tags), sparse = TRUE)
  for(i in 1:length(RGtags)){
    tag = RGtags[i]
    if(VERBOSE){
      message("Processing tag ", tag)
    }
    match_RG <- which(scanned$tag$RG == tag)
    # convert bamfiles to Genomic Ranges
    bam.gr = GRanges(seqnames = scanned$rname[match_RG],
                     IRanges(start = sapply(match_RG, function(i) ifelse(scanned$strand[i] == "-",
                                                                         scanned$pos[i] + scanned$qwidth[i] - 1,
                                                                         scanned$pos[i])),
                             width = scanned$qwidth[match_RG]))
    counts_mat[,i] = countOverlaps(peaks, bam.gr, type = "any", ignore.strand = TRUE)
  }
 # counts = do.call(cbind, lapply(RGtags, function(x) getTagCounts(x, bamfile, peaks)))
  colnames(counts_mat) = RGtags

  return(counts_mat)
}


#' get counts matrix
#'
#' Obtain counts matrix from bamfiles and peaks
#'
#' @param bamfiles a vector of filenames of input bam files
#' @param peaks a bed15 format file returned from select_peaks
#' @param paired a boolean variable indicating whether the experiment was paired end or not
#' @param byReadGroup boolean variable indicating whether or not individual experiments are separated by read group
#' @param RGtag read group tag, default = RG
#' @param tags2include read groups to include, if only a subset is desired
#' @param VERBOSE a boolean variable to indicate whether to print update messages
#' @return a matrix of chrom, start, end of peaks followed by counts of each bam file in bamfiles
#' @import Rsamtools
#' @import GenomicRanges
#' @import IRanges
#' @import Matrix
#' @keywords peaks
#' @keywords counts
#' @export getCountsMatrix
getCountsMatrix <- function(bamfiles, peaks, PAIRED = FALSE,
                            byReadGroup = FALSE, 
                            RGtag = 'RG',
                            tags2include = NULL, 
                            VERBOSE = FALSE){
  peaks.gr = peaks2GRanges(peaks)
  if(VERBOSE){
    message("beginning reading in counts\n")
  }
  if(byReadGroup){
    if(VERBOSE){
      message("getting counts by read group\n")
      message("read group tag = ", RGtag, "\n")
    }
    stopifnot(length(bamfiles) == 1)
    counts_mat = getCountsByReadGroup(bamfiles, peaks.gr, RGtag = RGtag, 
                                      tags2include);
    rownames(counts_mat) = peaks$name
  }
  else{
    nCells = length(bamfiles)
    counts_mat = matrix(nrow = length(peaks.gr), ncol = nCells)
    for(i in 1:nCells){
      if(VERBOSE){
        message("Processing file ", bamfiles[i])
      }
      # convert bamfiles to Genomic Ranges
      bam.gr = bam2gr(bamfiles[i], PAIRED = PAIRED)
      counts_mat[,i] = countOverlaps(peaks.gr, bam.gr, type = "any", ignore.strand = TRUE)
    }
    colnames(counts_mat) = bamfiles
    rownames(counts_mat) = peaks$name
    #counts_info = data.frame(chrom = counts_list[[1]]$space, start = counts_list[[1]]$start, end = counts_list[[1]]$end, name = peaks$id, pValue = peaks$pVal)
  }
  peaks = peaks[,c("chrom", "start", "end", "name", "pValue")]
  return(list(peaks = peaks, ForeGroundMatrix = Matrix::Matrix(counts_mat, sparse = TRUE)))
}

#' compute background counts matrix
#'
#' @param bamfiles a vector of filenames of input bamfiles
#' @param peaks a bed15 format file returned from select peaks
#' @param upstream number of bases upstream of peak to consider for computing background
#' @param downstream number of bases downstream of peak to consider for computing background
#' @return a matrix of chrom, start, end of peaks followed by background counts for each bam file in bamfiles
#' @import Rsamtools
#' @import GenomicRanges
#' @import IRanges
#' @import Matrix
#' @export getBackground
getBackground <- function(bamfiles, peaks, upstream = 500000,
                          downstream = 500000, byReadGroup = FALSE,
                          VERBOSE = FALSE, PAIRED = FALSE){
  nCells = length(bamfiles)
  background_peaks.gr = peaks2GRanges(peaks, upstream, downstream)
  if(byReadGroup){
    counts_mat = getCountsByReadGroup2(bamfile, background_peaks.gr);
    rownames(counts_mat) = peaks$name
  }
  else{
    counts_mat = matrix(nrow = length(background_peaks.gr), ncol = nCells)
    for(i in 1:nCells){
      if(VERBOSE){
        message("Processing file ", bamfiles[i])
      }
      # convert bamfiles to Genomic Ranges
      bam.gr = bam2gr(bamfiles[i], PAIRED = PAIRED)
      counts_mat[,i] = countOverlaps(background_peaks.gr, bam.gr, type = "any", ignore.strand = TRUE)
    }
    colnames(counts_mat) = bamfiles
    rownames(counts_mat) = peaks$name
    #counts_info = data.frame(chrom = counts_list[[1]]$space, start = counts_list[[1]]$start, end = counts_list[[1]]$end, name = peaks$id, pValue = peaks$pVal)
  }
  peaks = peaks[,c("chrom", "start", "end", "name", "pValue")]
  return(list(peaks = peaks, BackGroundMatrix = Matrix::Matrix(counts_mat, sparse = TRUE)))
}


# from chromVAR
#' @importFrom IRanges PartitioningByEnd
#' @importFrom BiocGenerics relist
bam2gr <- function(bamfile, PAIRED = FALSE) {
  if (PAIRED) {
    scanned = scanBam(bamfile, param = ScanBamParam(flag =scanBamFlag(isMinusStrand = FALSE,
                                                                      isProperPair = TRUE),
                                                    what = c("rname", "pos", "isize")))[[1]]
    out = GRanges(seqnames = scanned$rname, IRanges(start = scanned$pos, width = scanned$isize))
  } else {
    scanned = scanBam(bamfile, param = ScanBamParam(what = c("rname", "pos",
                                                     "strand",
                                                     "qwidth")))[[1]]
    out = GRanges(seqnames = scanned$rname,
                  IRanges(start = ifelse(scanned$strand == "-", scanned$pos + scanned$qwidth - 1, scanned$pos),
                          width = scanned$qwidth))
  }
  return(out)
}


#' filter samples by comparing foreground against background
#'
#' @param ForeGround sparse matrix of ForeGround values
#' @param BackGround sparse of BackGround values
#' @param readsFGthresh threshold for the total reads per cell in ForeGround. Default is min(500, number of peaks/50)
#' @import Matrix
#' @return filtered ForeGround and BackGround
#' @export filterSamples
filterSamples <- function(ForeGround, BackGround, readsFGthresh=NULL){
  stopifnot(dim(ForeGround) == dim(BackGround))
  if (is.null(readsFGthresh)){
    readsFGthresh <- min(500, nrow(ForeGround)/50)
  }
  which_samples_pass = which(Matrix::colSums(ForeGround) > readsFGthresh)
  return(list(ForeGroundMatrix = ForeGround[,which_samples_pass],
              BackGroundMatrix = BackGround[,which_samples_pass]))
}

#' filter peaks
#'
#' @param ForeGround sparse matrix of Foreground values
#' @param peaks a bed format file of peaks
#' @param nreads_thresh threshold of the number of reads
#' @param ncells_thresh threshold of the number of cells
#' @import Matrix
#' @return filtered ForeGround and peaks
#' @export filterPeaks
filterPeaks <- function(ForeGround, peaks, nreads_thresh = 1, ncells_thresh = 10){
  which_peaks_pass = which(Matrix::rowSums(ForeGround[,4:dim(ForeGround)[2]] >= nreads_thresh) >= ncells_thresh)
  return(list(ForeGroundMatrix = ForeGround[which_peaks_pass,], peaks = peaks[which_peaks_pass, ]))
}

